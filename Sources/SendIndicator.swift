//
//  StyleKit.swift
//  SendIndicator
//
//  Created by Leonardo Cardoso on 31/05/2017.
//  Copyright Â© 2017 leocardz.com. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class StyleKit : NSObject {

     public static func drawSource(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 120, height: 70), resizing: ResizingBehavior = .aspectFit, palette: Palette, flow: CGFloat = 0, initialArrowX: CGFloat = 70, offset: CGFloat = 19) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 120, height: 70), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 120, y: resizedFrame.height / 70)



        //// Variable Declarations
        let multiplier: CGFloat = flow * 38
        let alpha1: CGFloat = 1 - flow - 0.5
        let alpha2: CGFloat = 1 - flow
        let alpha4: CGFloat = flow
        let alpha5: CGFloat = flow - 0.5
        let arrow1X: CGFloat = initialArrowX + multiplier
        let arrow2X: CGFloat = arrow1X - offset
        let arrow3X: CGFloat = arrow2X - offset
        let arrow4X: CGFloat = arrow3X - offset
        let arrow5X: CGFloat = arrow4X - offset
        let alpha3: CGFloat = arrow1X >= initialArrowX + offset ? 1 - flow + 0.5 : flow + 0.5

        //// Arrow 1 Drawing
        context.saveGState()
        context.translateBy(x: arrow1X, y: 61)

        context.saveGState()
        context.setAlpha(alpha1)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let arrow1Rect = CGRect(x: 0, y: -52, width: 26, height: 52)
        context.saveGState()
        context.clip(to: arrow1Rect)
        context.translateBy(x: arrow1Rect.minX, y: arrow1Rect.minY)

        StyleKit.drawCanvasArrow(frame: CGRect(origin: .zero, size: arrow1Rect.size), resizing: .stretch, palette: palette)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()


        //// Arrow 2 Drawing
        context.saveGState()
        context.setAlpha(alpha2)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let arrow2Rect = CGRect(x: arrow2X, y: 9, width: 26, height: 52)
        context.saveGState()
        context.clip(to: arrow2Rect)
        context.translateBy(x: arrow2Rect.minX, y: arrow2Rect.minY)

        StyleKit.drawCanvasArrow(frame: CGRect(origin: .zero, size: arrow2Rect.size), resizing: .stretch, palette: palette)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()


        //// Arrow 3 Drawing
        context.saveGState()
        context.setAlpha(alpha3)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let arrow3Rect = CGRect(x: arrow3X, y: 9, width: 26, height: 52)
        context.saveGState()
        context.clip(to: arrow3Rect)
        context.translateBy(x: arrow3Rect.minX, y: arrow3Rect.minY)

        StyleKit.drawCanvasArrow(frame: CGRect(origin: .zero, size: arrow3Rect.size), resizing: .stretch, palette: palette)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()


        //// Arrow 4 Drawing
        context.saveGState()
        context.setAlpha(alpha4)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let arrow4Rect = CGRect(x: arrow4X, y: 9, width: 26, height: 52)
        context.saveGState()
        context.clip(to: arrow4Rect)
        context.translateBy(x: arrow4Rect.minX, y: arrow4Rect.minY)

        StyleKit.drawCanvasArrow(frame: CGRect(origin: .zero, size: arrow4Rect.size), resizing: .stretch, palette: palette)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()


        //// Arrow 5 Drawing
        context.saveGState()
        context.setAlpha(alpha5)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        let arrow5Rect = CGRect(x: arrow5X, y: 9, width: 26, height: 52)
        context.saveGState()
        context.clip(to: arrow5Rect)
        context.translateBy(x: arrow5Rect.minX, y: arrow5Rect.minY)

        StyleKit.drawCanvasArrow(frame: CGRect(origin: .zero, size: arrow5Rect.size), resizing: .stretch, palette: palette)
        context.restoreGState()

        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()

    }

    private static func drawCanvasArrow(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 26, height: 52), resizing: ResizingBehavior = .aspectFit, palette: Palette) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 26, height: 52), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 26, y: resizedFrame.height / 52)


        //// Arrow Drawing
        let arrowPath = UIBezierPath()
        arrowPath.move(to: CGPoint(x: 26, y: 26))
        arrowPath.addLine(to: CGPoint(x: 0, y: 0))
        arrowPath.addLine(to: CGPoint(x: 0, y: 13))
        arrowPath.addLine(to: CGPoint(x: 13, y: 26))
        arrowPath.addLine(to: CGPoint(x: 0, y: 39))
        arrowPath.addLine(to: CGPoint(x: 0, y: 52))
        arrowPath.addLine(to: CGPoint(x: 26, y: 26))
        arrowPath.close()
        palette.indicatorColor.setFill()
        arrowPath.fill()

        context.restoreGState()

    }




    @objc(StyleKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}

open class Palette {

    var indicatorColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

    public init(indicatorColor: UIColor? = nil) {

        self.indicatorColor = indicatorColor ?? self.indicatorColor

    }

}

class SendIndicatorLayer: CALayer {

    // MARK: - Properties
    @NSManaged var flow: CGFloat

    // MARK: - Initializers
    override init() {

        super.init()

        flow = 0.0

    }

    override init(layer: Any) {

        super.init(layer: layer)

        if let layer = layer as? SendIndicatorLayer {

            flow = layer.flow

        }

    }

    required init?(coder aDecoder: NSCoder) {

        fatalError("init(coder:) has not been implemented")

    }

    // MARK: - Lifecyle
    override class func needsDisplay(forKey key: String?) -> Bool {

        guard let key = key else { return false }

        if SendIndicatorLayer.isCompatible(key) {

            return true

        }

        return super.needsDisplay(forKey: key)

    }

    override func action(forKey event: String?) -> CAAction? {

        guard let event = event else { return nil }

        if SendIndicatorLayer.isCompatible(event) {

            let animation = CABasicAnimation.init(keyPath: event)
            animation.fromValue = presentation()?.value(forKey: event)

            return animation

        }

        return super.action(forKey: event)
    }

    // MARK: - Functions
    private static func isCompatible(_ key: String) -> Bool {

        return key == "flow"

    }

}

internal class Flow {

    // MARK: - Functions
    // Execute code block asynchronously
    static func async(block: @escaping () -> Void) {

        DispatchQueue.main.async(execute: block)

    }

    // Execute code block asynchronously after given delay time
    static func delay(for delay: TimeInterval, block: @escaping () -> Void) {

        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + delay, execute: block)
        
    }
    
}


@IBDesignable
open class SendIndicator: UIView {

    // MARK: - IBDesignable and IBInspectable
    @IBInspectable var indicatorColor: UIColor? {

        didSet {

            palette.indicatorColor = indicatorColor ?? palette.indicatorColor

        }

    }

    // MARK: - Properties
    var keyPath: String = "flow"
    var palette: Palette = Palette()

    override open class var layerClass: AnyClass {

        return SendIndicatorLayer.self

    }

    override init(frame: CGRect) {

        super.init(frame: frame)

    }

    public init(frame: CGRect, palette: Palette = Palette()) {

        super.init(frame: frame)

        self.palette = palette

        draw()

    }

    required public init?(coder aDecoder: NSCoder) {

        super.init(coder: aDecoder)

    }

    // MARK: - Lifecyle
    override open func awakeFromNib() {

        super.awakeFromNib()

        draw()

    }

    override open func draw(_ layer: CALayer, in ctx: CGContext) {

        guard let layer: SendIndicatorLayer = layer as? SendIndicatorLayer else { return }

        let frame = CGRect(origin: CGPoint(x: 0, y: 0), size: layer.frame.size)

        UIGraphicsPushContext(ctx)

        switch keyPath {

        case "flow":

            StyleKit.drawSource(frame: frame, palette: palette, flow: layer.flow)
            break

        default:

            break

        }

        UIGraphicsPopContext()

    }

    // MARK: - Functions
    private func resetManipulables() {

        guard let layer: SendIndicatorLayer = layer as? SendIndicatorLayer else { return }

        layer.flow = 0.0

    }

    func draw() {

        needsDisplay()

    }

    func needsDisplay() {

        layer.contentsScale = UIScreen.main.scale
        layer.setNeedsDisplay()

    }

    public func startAnimation() {

        self.animate(keyPath: "flow")

    }

    public func stopAnimation() {

        self.animate(from: 0, to: 0, keyPath: "flow")
        resetManipulables()

    }

    fileprivate func animate(duration: TimeInterval = 0.8, delay: TimeInterval = 0, from: CGFloat = 0, to: CGFloat = 1, keyPath: String) -> Void {

        guard let layer: SendIndicatorLayer = layer as? SendIndicatorLayer else { return }

        self.keyPath = keyPath

        let animation = CABasicAnimation(keyPath: keyPath)
        animation.beginTime = CACurrentMediaTime() + delay
        animation.duration = duration
        animation.fillMode = kCAFillModeBoth
        animation.timingFunction = CAMediaTimingFunction.init(name: kCAMediaTimingFunctionLinear)
        animation.fromValue = from
        animation.toValue = to
        animation.repeatCount = .infinity

        layer.add(animation, forKey: nil)

        Flow.async {

            CATransaction.begin()
            CATransaction.setDisableActions(true)
            self.updateManipulable(layer, keyPath, to)
            CATransaction.commit()

        }

    }

    private func updateManipulable(_ layer: SendIndicatorLayer, _ keyPath: String, _ value: CGFloat) {

        switch keyPath {

        case "flow":

            layer.flow = value
            return
            
        default:
            
            return
            
        }
        
    }
    
}
